#!/usr/bin/env python

"""
Converts txt file to csv file.
Uses py2 for backwards compatibility,
with some py3 features like print()
"""

from __future__ import print_function
import argparse
import csv
import io
import os
import re
import sys

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("path", help="Path to .txt file")
    parser.add_argument("-n", "--numbered", type=int,
                        help="Indicate whether items are numbered and which line is numbered")
    parser.add_argument("-x", "--exclude", type=int, nargs="*",
                        help="Specify which line(s) to exclude")
    parser.add_argument("-o", "--output", type=str,
                        help="Specifiy output path")

    args = parser.parse_args()
    input_path = args.path
    numbered_line = args.numbered
    exclude_lines = args.exclude
    output_path = args.output

    # Input check
    if not os.path.exists(input_path):
        print("{} doesn't exist. Any typo?".format(input_path))
        sys.exit(1)

    # Output check
    if not output_path:
        output_path = os.path.splitext(input_path)[0] + ".csv"
    elif os.path.splitext(output_path)[1] != ".csv":
        print("Output path must end in .csv")
        sys.exit(1)

    # I/O ok, let's do some work
    with io.open(input_path, mode="r", encoding="utf-8-sig") as txt_file:
        input_text =  txt_file.read().strip()

    items = turn_to_list(input_text)

    # Make sure user isn't asking to exclude lines beyond shortest chunk
    if exclude_lines and max(exclude_lines) > find_shortest(items):
        print("Excluded lines out of range: {} is the shortest chunk size".format(shortest_chunk))
        sys.exit(1)

    # Separate inline numbering if user asks for it
    if numbered_line:
        items = separate_numbered(items, numbered_line)

    # All done processing, write to file
    write_csv(items, exclude_lines, output_path)


def find_shortest(items_list):
    """ Find shortest chunk length
    """
    shortest = len(items_list[0])
    for item in items_list:
        if len(item) < shortest:
            shortest = len(item)
    return shortest
        

def turn_to_list(input_str):
    """ Clean up input string and returns a list of lists:
    [[id #, 12 Name, location], [id#, 13 Name, location]]
    """
    chunks = re.sub("\n\s*\n", "\n\n", input_str)
    chunks = chunks.split("\n\n")
    return [chunk.splitlines() for chunk in chunks]


def separate_numbered(chunks, number_line):
    """ Separate inline numbering into its own cell
    [[id #, 12, Name, location], [id#, 13, Name, location]]
    """
    return_chunks = []
    for chunk in chunks:
        new_chunk = []
        for index, item in enumerate(chunk):
            if index != number_line - 1:
                new_chunk.append(item)
            else:
                split_line = item.split(" ", 1)
                new_chunk += split_line
        
        return_chunks.append(new_chunk)
    return return_chunks


def write_csv(items, exclude_cells, file_path="./output.csv"):
    """ Write CSV file to path
    Items is a list, where each item is a CSV row
    """
    with open(file_path, mode="wb+") as out_file:
        writer = csv.writer(out_file, dialect="excel")
        items = encode_items_utf8(items)

        for row in items:
            if exclude_cells:
                row = [cell for i, cell in enumerate(row)\
                       if i + 1 not in exclude_cells]

            writer.writerow(row)


def encode_items_utf8(items, collection=[]):
    """ Recursively encode every unicode item in an items list
    to UTF-8 bytestring
    """
    return_list = []
    for item in items:
        if isinstance(item, list):
            return_list.append(encode_items_utf8(item))
        else:
            return_list.append(item.encode("utf-8"))
    return return_list


if __name__ == "__main__":
    main()

